<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Disclaimer</span></a></li>
      <li><a href="_xE9_xA6_x96_xE9_xA1_xB5.html"><span>Home&#160;Page</span></a></li>
      <li><a href="_s_d_k_xE7_x89_x88_xE6_x9C_xAC_xE6_x9B_xB4_xE6_x96_xB0_xE8_xAE_xB0_xE5_xBD_x95.html"><span>Update&#160;History</span></a></li>
      <li><a href="usergroup0.html"><span>Programming&#160;Guide</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference&#160;and&#160;Data&#160;Structure</span></a></li>
      <li><a href="_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F.html"><span>Sample&#160;Program</span></a></li>
      <li><a href="_error_code.html"><span>Error&#160;Code</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Acquiring Images</div>  </div>
</div><!--header-->
<div class="contents">

<p>Get stream information, open and close stream, register and revoke buffers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab17defc955fd688f9446bd0045428870"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a> hDevice, OUT unsigned int *pnNumStreams)</td></tr>
<tr class="memdesc:gab17defc955fd688f9446bd0045428870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of stream channels.  <a href="#gab17defc955fd688f9446bd0045428870">More...</a><br /></td></tr>
<tr class="separator:gab17defc955fd688f9446bd0045428870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baadf4aae39d682049189eeb3dba3c9"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a> hDevice, IN unsigned int nIndex, OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> *phStream)</td></tr>
<tr class="memdesc:ga5baadf4aae39d682049189eeb3dba3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the stream channel.  <a href="#ga5baadf4aae39d682049189eeb3dba3c9">More...</a><br /></td></tr>
<tr class="separator:ga5baadf4aae39d682049189eeb3dba3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5479a027ca49239ca1e9253e986008"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream)</td></tr>
<tr class="memdesc:ga7d5479a027ca49239ca1e9253e986008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the stream channel.  <a href="#ga7d5479a027ca49239ca1e9253e986008">More...</a><br /></td></tr>
<tr class="separator:ga7d5479a027ca49239ca1e9253e986008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf595b8cea350b96d8c156a26c0c7ed6"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6">MV_FG_SetBufferNum</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN unsigned int nBufferNum)</td></tr>
<tr class="memdesc:gabf595b8cea350b96d8c156a26c0c7ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of internal buffers for the SDK.  <a href="#gabf595b8cea350b96d8c156a26c0c7ed6">More...</a><br /></td></tr>
<tr class="separator:gabf595b8cea350b96d8c156a26c0c7ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41f3a68612ff0df995d91306d4e971fe"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga41f3a68612ff0df995d91306d4e971fe">MV_FG_SetGrabStrategy</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga32523e01d58a150ced054a22cb911f34">MV_FG_GRAB_STRATEGY</a> enGrabStrategy, bool8_t bUseTrashBuffer)</td></tr>
<tr class="memdesc:ga41f3a68612ff0df995d91306d4e971fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set acquisition strategy.  <a href="#ga41f3a68612ff0df995d91306d4e971fe">More...</a><br /></td></tr>
<tr class="separator:ga41f3a68612ff0df995d91306d4e971fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7b5df83580c256b5f6fc53c7875246"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabe7b5df83580c256b5f6fc53c7875246">MV_FG_RegisterFrameCallBack</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a> cbFrame, IN void *pUser)</td></tr>
<tr class="memdesc:gabe7b5df83580c256b5f6fc53c7875246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback function for frame buffer information. This API is valid only when buffers are requested internally by the SDK.  <a href="#gabe7b5df83580c256b5f6fc53c7875246">More...</a><br /></td></tr>
<tr class="separator:gabe7b5df83580c256b5f6fc53c7875246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115ef26be9f043456d805dc47d99dc18"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18">MV_FG_RegisterFrameCallBackEx</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a> cbFrame, IN void *pUser, IN bool8_t bBufferRelease)</td></tr>
<tr class="memdesc:ga115ef26be9f043456d805dc47d99dc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the callback function for frame buffer information. This API is valid only when buffers are requested internally by the SDK.<br />
 This API is an extended version of MV_FG_RegisterFrameCallBack. You can specify a buffer releasing method in the parameter bBufferRelease.  <a href="#ga115ef26be9f043456d805dc47d99dc18">More...</a><br /></td></tr>
<tr class="separator:ga115ef26be9f043456d805dc47d99dc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab802fc25610648224ff8298c64bceb3d"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d">MV_FG_GetFrameBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo, IN unsigned int nTimeout)</td></tr>
<tr class="memdesc:gab802fc25610648224ff8298c64bceb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer information of a frame. This API is valid only when buffers are requested internally by the SDK.  <a href="#gab802fc25610648224ff8298c64bceb3d">More...</a><br /></td></tr>
<tr class="separator:gab802fc25610648224ff8298c64bceb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a80ef9329039ac8d7f47f03e0720cfc"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc">MV_FG_ReleaseFrameBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo)</td></tr>
<tr class="memdesc:ga0a80ef9329039ac8d7f47f03e0720cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the buffer information. This API is valid only when buffers are requested internally by the SDK.  <a href="#ga0a80ef9329039ac8d7f47f03e0720cfc">More...</a><br /></td></tr>
<tr class="separator:ga0a80ef9329039ac8d7f47f03e0720cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f77d11bcbc21d52cc5b6173d23a367d"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2f77d11bcbc21d52cc5b6173d23a367d">MV_FG_GetBufferChunkData</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo, IN unsigned int nIndex, OUT <a class="el" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a> *pstChunkDataInfo)</td></tr>
<tr class="memdesc:ga2f77d11bcbc21d52cc5b6173d23a367d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chunk data information in the buffer.  <a href="#ga2f77d11bcbc21d52cc5b6173d23a367d">More...</a><br /></td></tr>
<tr class="separator:ga2f77d11bcbc21d52cc5b6173d23a367d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14550b8b6ea4796171669a0bbdd68550"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550">MV_FG_GetPayloadSize</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, OUT unsigned int *pnPayloadSize)</td></tr>
<tr class="memdesc:ga14550b8b6ea4796171669a0bbdd68550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image size in the stream channel.  <a href="#ga14550b8b6ea4796171669a0bbdd68550">More...</a><br /></td></tr>
<tr class="separator:ga14550b8b6ea4796171669a0bbdd68550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa876df36c0ad4be0e2c7184e5076a0c7"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7">MV_FG_AnnounceBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN void *pBuffer, IN unsigned int nSize, IN void *pPrivate, OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *phBuffer)</td></tr>
<tr class="memdesc:gaa876df36c0ad4be0e2c7184e5076a0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register buffer to the stream channel. This API must be called before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a> .  <a href="#gaa876df36c0ad4be0e2c7184e5076a0c7">More...</a><br /></td></tr>
<tr class="separator:gaa876df36c0ad4be0e2c7184e5076a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14afae1d79a9402ac008fa463713f3e6"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14afae1d79a9402ac008fa463713f3e6">MV_FG_RevokeBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer, OUT void **pBuffer, OUT void **pPrivate)</td></tr>
<tr class="memdesc:ga14afae1d79a9402ac008fa463713f3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revoke buffer from the stream channel registered by <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="Register buffer to the stream channel. This API must be called before calling MV_FG_StartAcquisition(...">MV_FG_AnnounceBuffer()</a> .  <a href="#ga14afae1d79a9402ac008fa463713f3e6">More...</a><br /></td></tr>
<tr class="separator:ga14afae1d79a9402ac008fa463713f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11288e3420c666956605afd2cd987c2c"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c">MV_FG_FlushQueue</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#gae5852b0e56ae9feccef5505206d78562">MV_FG_BUFFER_QUEUE_TYPE</a> enQueueType)</td></tr>
<tr class="memdesc:ga11288e3420c666956605afd2cd987c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the buffer queue.  <a href="#ga11288e3420c666956605afd2cd987c2c">More...</a><br /></td></tr>
<tr class="separator:ga11288e3420c666956605afd2cd987c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1772dd2bc2a1ddf9fbc28044cd6742a"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream)</td></tr>
<tr class="memdesc:gac1772dd2bc2a1ddf9fbc28044cd6742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start image acquisition.  <a href="#gac1772dd2bc2a1ddf9fbc28044cd6742a">More...</a><br /></td></tr>
<tr class="separator:gac1772dd2bc2a1ddf9fbc28044cd6742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230e6896d6400514748b593b9d3c704b"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream)</td></tr>
<tr class="memdesc:ga230e6896d6400514748b593b9d3c704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop image acquisition.  <a href="#ga230e6896d6400514748b593b9d3c704b">More...</a><br /></td></tr>
<tr class="separator:ga230e6896d6400514748b593b9d3c704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ab6d598e6b313d373ccc6242c2dfba"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba">MV_FG_GetImageBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *phBuffer, IN unsigned int nTimeout)</td></tr>
<tr class="memdesc:ga14ab6d598e6b313d373ccc6242c2dfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer handle of a frame. This API is valid only when buffers are registered via <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="Register buffer to the stream channel. This API must be called before calling MV_FG_StartAcquisition(...">MV_FG_AnnounceBuffer()</a>.  <a href="#ga14ab6d598e6b313d373ccc6242c2dfba">More...</a><br /></td></tr>
<tr class="separator:ga14ab6d598e6b313d373ccc6242c2dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6984ec4a8ff98ff1257fa5052de01b06"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06">MV_FG_GetBufferInfo</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer, OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo)</td></tr>
<tr class="memdesc:ga6984ec4a8ff98ff1257fa5052de01b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer information via buffer handle.  <a href="#ga6984ec4a8ff98ff1257fa5052de01b06">More...</a><br /></td></tr>
<tr class="separator:ga6984ec4a8ff98ff1257fa5052de01b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7086bb942615bfeae3078d0342e230de"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de">MV_FG_QueueBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer)</td></tr>
<tr class="memdesc:ga7086bb942615bfeae3078d0342e230de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the buffer back to the input queue for further image acquisition.  <a href="#ga7086bb942615bfeae3078d0342e230de">More...</a><br /></td></tr>
<tr class="separator:ga7086bb942615bfeae3078d0342e230de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Get stream information, open and close stream, register and revoke buffers. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab17defc955fd688f9446bd0045428870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab17defc955fd688f9446bd0045428870">&#9670;&nbsp;</a></span>MV_FG_GetNumStreams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetNumStreams </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnNumStreams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of stream channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>[IN] Camera handle. </td></tr>
    <tr><td class="paramname">pnNumStreams</td><td>[OUT] Number of stream channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Currently, a camera only supports one stream channel. </dd></dl>

</div>
</div>
<a id="ga5baadf4aae39d682049189eeb3dba3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5baadf4aae39d682049189eeb3dba3c9">&#9670;&nbsp;</a></span>MV_FG_OpenStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_OpenStream </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> *&#160;</td>
          <td class="paramname"><em>phStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the stream channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>[IN] Camera handle. </td></tr>
    <tr><td class="paramname">nIndex</td><td>[IN] Stream channel index. </td></tr>
    <tr><td class="paramname">phStream</td><td>[OUT] Stream channel handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>

</div>
</div>
<a id="ga7d5479a027ca49239ca1e9253e986008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5479a027ca49239ca1e9253e986008">&#9670;&nbsp;</a></span>MV_FG_CloseStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_CloseStream </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the stream channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>

</div>
</div>
<a id="gabf595b8cea350b96d8c156a26c0c7ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf595b8cea350b96d8c156a26c0c7ed6">&#9670;&nbsp;</a></span>MV_FG_SetBufferNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_SetBufferNum </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nBufferNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of internal buffers for the SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">nBufferNum</td><td>[IN] Number of buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The SDK has no internal buffer if this API is not called or the value of parameter nBufferNum is set to 0.<br />
 When there is no internal buffer, you need to request and register buffers to the stream channel before image acquisition. <br />
 When the parameter nBufferNum is set to a value greater than 0, buffers will be registered internally by the SDK, and it is not allowed to register buffers to stream channels at this time. <br />
 The number of image buffers should be reasonably allocated. For Linux operating systems, if the number of image buffers is too large, then the system memory will be too small and the program will be ended by the operating system. </dd></dl>

</div>
</div>
<a id="ga41f3a68612ff0df995d91306d4e971fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41f3a68612ff0df995d91306d4e971fe">&#9670;&nbsp;</a></span>MV_FG_SetGrabStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_SetGrabStrategy </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga32523e01d58a150ced054a22cb911f34">MV_FG_GRAB_STRATEGY</a>&#160;</td>
          <td class="paramname"><em>enGrabStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool8_t&#160;</td>
          <td class="paramname"><em>bUseTrashBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set acquisition strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">enGrabStrategy</td><td>[IN] Acquisition strategy. </td></tr>
    <tr><td class="paramname">bUseTrashBuffer</td><td>[IN] Whether to use trash buffer: 0-disable, 1-enable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API defines 4 acquisition strategies, which can be selected as needed. <br />
<ul>
<li>OneByOne: Get images frame by frame from old to new in the output buffer list. After the stream channel is created, it is the default strategy. <br />
</li>
<li>LatestImagesOnly: Only get the latest frame of image in the output buffer list, and clear the output buffer list at the same time. <br />
</li>
<li>LatestImages: Get the latest image without clearing the output buffer list. <br />
</li>
<li>UpcomingImage: Clear all the images in the output buffer list when calling the acquisition API, and wait for the next frame generated by the camera.</li>
</ul>
</dd>
<dd>
When the parameter bUseTrashBuffer=true, if the registered buffers are all used and are not put back to queue by calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> \ <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de" title="Put the buffer back to the input queue for further image acquisition.">MV_FG_QueueBuffer()</a> \ <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="Refresh the buffer queue.">MV_FG_FlushQueue()</a> , then trash buffers will be used for receiving images. At this time, the received images will be discarded, so as to avoid image loss in the frame grabber. </dd></dl>

</div>
</div>
<a id="gabe7b5df83580c256b5f6fc53c7875246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe7b5df83580c256b5f6fc53c7875246">&#9670;&nbsp;</a></span>MV_FG_RegisterFrameCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_RegisterFrameCallBack </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a>&#160;</td>
          <td class="paramname"><em>cbFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback function for frame buffer information. This API is valid only when buffers are requested internally by the SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">cbFrame</td><td>[IN] Frame buffer information callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] User-defined data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Time-consuming operations in the callback function will block the access to the subsequent frame buffer information. <br />
 This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="Get the buffer information of a frame. This API is valid only when buffers are requested internally b...">MV_FG_GetFrameBuffer()</a> are mutually exclusive. <br />
 You need to call this API to register the callback function before calling API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a> . </dd></dl>

</div>
</div>
<a id="ga115ef26be9f043456d805dc47d99dc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115ef26be9f043456d805dc47d99dc18">&#9670;&nbsp;</a></span>MV_FG_RegisterFrameCallBackEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_RegisterFrameCallBackEx </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a>&#160;</td>
          <td class="paramname"><em>cbFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN bool8_t&#160;</td>
          <td class="paramname"><em>bBufferRelease</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the callback function for frame buffer information. This API is valid only when buffers are requested internally by the SDK.<br />
 This API is an extended version of MV_FG_RegisterFrameCallBack. You can specify a buffer releasing method in the parameter bBufferRelease. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">cbFrame</td><td>[IN] Frame buffer information callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] User-defined data. </td></tr>
    <tr><td class="paramname">bBufferRelease</td><td>[IN] Method of releasing buffer. 1: The buffer will be released automatically after the callback function ends. 0: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> to release the buffer after the callback function ends.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Time-consuming operations in the callback function will block the access to the subsequent frame buffer information. <br />
 This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="Get the buffer information of a frame. This API is valid only when buffers are requested internally b...">MV_FG_GetFrameBuffer()</a> are mutually exclusive. <br />
 You need to call this API to register the callback function before calling API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a> .<br />
</dd></dl>

</div>
</div>
<a id="gab802fc25610648224ff8298c64bceb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab802fc25610648224ff8298c64bceb3d">&#9670;&nbsp;</a></span>MV_FG_GetFrameBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetFrameBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer information of a frame. This API is valid only when buffers are requested internally by the SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[OUT] Buffer information. </td></tr>
    <tr><td class="paramname">nTimeout</td><td>[IN] Timeout, unit: millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> should be called to release the buffer information. </dd></dl>

</div>
</div>
<a id="ga0a80ef9329039ac8d7f47f03e0720cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a80ef9329039ac8d7f47f03e0720cfc">&#9670;&nbsp;</a></span>MV_FG_ReleaseFrameBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_ReleaseFrameBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the buffer information. This API is valid only when buffers are requested internally by the SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[IN] Buffer information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API is used to release the image buffer which is no longer used. <br />
 This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="Get the buffer information of a frame. This API is valid only when buffers are requested internally b...">MV_FG_GetFrameBuffer()</a> should be used in pair. The image data (pstBufferInfo) obtained via <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="Get the buffer information of a frame. This API is valid only when buffers are requested internally b...">MV_FG_GetFrameBuffer()</a> should be released by this API. </dd></dl>

</div>
</div>
<a id="ga2f77d11bcbc21d52cc5b6173d23a367d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f77d11bcbc21d52cc5b6173d23a367d">&#9670;&nbsp;</a></span>MV_FG_GetBufferChunkData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetBufferChunkData </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstChunkDataInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the chunk data information in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[IN] Buffer information. </td></tr>
    <tr><td class="paramname">nIndex</td><td>[IN] Chunk data index. </td></tr>
    <tr><td class="paramname">pstChunkDataInfo</td><td>[OUT] Chunk data information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>After getting the buffer information, this API must be called before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> / <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de" title="Put the buffer back to the input queue for further image acquisition.">MV_FG_QueueBuffer()</a> to get valid information of the chunk data. </dd></dl>

</div>
</div>
<a id="ga14550b8b6ea4796171669a0bbdd68550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14550b8b6ea4796171669a0bbdd68550">&#9670;&nbsp;</a></span>MV_FG_GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetPayloadSize </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnPayloadSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the image size in the stream channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">pnPayloadSize</td><td>[OUT] Image size in the stream channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The image size in the stream channel needs to be acquired again after the image-related parameters of the camera are changed, such as width, height, and pixel format. </dd></dl>

</div>
</div>
<a id="gaa876df36c0ad4be0e2c7184e5076a0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa876df36c0ad4be0e2c7184e5076a0c7">&#9670;&nbsp;</a></span>MV_FG_AnnounceBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_AnnounceBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pPrivate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *&#160;</td>
          <td class="paramname"><em>phBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register buffer to the stream channel. This API must be called before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>[IN] Image buffer address. </td></tr>
    <tr><td class="paramname">nSize</td><td>[IN] Image buffer size. </td></tr>
    <tr><td class="paramname">pPrivate</td><td>[IN] Private information address. </td></tr>
    <tr><td class="paramname">phBuffer</td><td>[OUT] Buffer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550" title="Get the image size in the stream channel.">MV_FG_GetPayloadSize()</a> to get image buffer size. The private information is defined by user. </dd></dl>

</div>
</div>
<a id="ga14afae1d79a9402ac008fa463713f3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14afae1d79a9402ac008fa463713f3e6">&#9670;&nbsp;</a></span>MV_FG_RevokeBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_RevokeBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a>&#160;</td>
          <td class="paramname"><em>hBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>pPrivate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Revoke buffer from the stream channel registered by <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="Register buffer to the stream channel. This API must be called before calling MV_FG_StartAcquisition(...">MV_FG_AnnounceBuffer()</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">hBuffer</td><td>[IN] Buffer handle. </td></tr>
    <tr><td class="paramname">pBuffer</td><td>[OUT] Image buffer address. </td></tr>
    <tr><td class="paramname">pPrivate</td><td>[OUT] Private information address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only buffers in the unused queue can be revoked. You can allocate buffers to unused queues by calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="Refresh the buffer queue.">MV_FG_FlushQueue()</a>. </dd></dl>

</div>
</div>
<a id="ga11288e3420c666956605afd2cd987c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11288e3420c666956605afd2cd987c2c">&#9670;&nbsp;</a></span>MV_FG_FlushQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_FlushQueue </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#gae5852b0e56ae9feccef5505206d78562">MV_FG_BUFFER_QUEUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>enQueueType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh the buffer queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">enQueueType</td><td>[IN] Buffer queue type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The following queue types are not supported during image acquisition: MV_FG_BUFFER_QUEUE_INPUT_TO_OUTPUT and MV_FG_BUFFER_QUEUE_ALL_DISCARD. </dd></dl>

</div>
</div>
<a id="gac1772dd2bc2a1ddf9fbc28044cd6742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1772dd2bc2a1ddf9fbc28044cd6742a">&#9670;&nbsp;</a></span>MV_FG_StartAcquisition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_StartAcquisition </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start image acquisition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>

</div>
</div>
<a id="ga230e6896d6400514748b593b9d3c704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga230e6896d6400514748b593b9d3c704b">&#9670;&nbsp;</a></span>MV_FG_StopAcquisition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_StopAcquisition </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop image acquisition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>

</div>
</div>
<a id="ga14ab6d598e6b313d373ccc6242c2dfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ab6d598e6b313d373ccc6242c2dfba">&#9670;&nbsp;</a></span>MV_FG_GetImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *&#160;</td>
          <td class="paramname"><em>phBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer handle of a frame. This API is valid only when buffers are registered via <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="Register buffer to the stream channel. This API must be called before calling MV_FG_StartAcquisition(...">MV_FG_AnnounceBuffer()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] Stream channel handle. </td></tr>
    <tr><td class="paramname">phBuffer</td><td>[OUT] Buffer handle. </td></tr>
    <tr><td class="paramname">nTimeout</td><td>[IN] Timeout, unit: ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>By calling the API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06" title="Get the buffer information via buffer handle.">MV_FG_GetBufferInfo()</a>, you can get the buffer information with the acquired buffer handle. </dd></dl>

</div>
</div>
<a id="ga6984ec4a8ff98ff1257fa5052de01b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6984ec4a8ff98ff1257fa5052de01b06">&#9670;&nbsp;</a></span>MV_FG_GetBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetBufferInfo </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a>&#160;</td>
          <td class="paramname"><em>hBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer information via buffer handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBuffer</td><td>[IN] Buffer handle. </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[OUT] Buffer information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>

</div>
</div>
<a id="ga7086bb942615bfeae3078d0342e230de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7086bb942615bfeae3078d0342e230de">&#9670;&nbsp;</a></span>MV_FG_QueueBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_QueueBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a>&#160;</td>
          <td class="paramname"><em>hBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the buffer back to the input queue for further image acquisition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBuffer</td><td>[IN] Buffer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_FG_SUCCESS</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer handle is from <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba" title="Get the buffer handle of a frame. This API is valid only when buffers are registered via MV_FG_Announ...">MV_FG_GetImageBuffer()</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>