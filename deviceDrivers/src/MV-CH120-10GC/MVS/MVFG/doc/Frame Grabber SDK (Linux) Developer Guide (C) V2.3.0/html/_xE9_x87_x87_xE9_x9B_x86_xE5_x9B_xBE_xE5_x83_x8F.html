<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Disclaimer</span></a></li>
      <li><a href="_xE9_xA6_x96_xE9_xA1_xB5.html"><span>Home&#160;Page</span></a></li>
      <li><a href="_s_d_k_xE7_x89_x88_xE6_x9C_xAC_xE6_x9B_xB4_xE6_x96_xB0_xE8_xAE_xB0_xE5_xBD_x95.html"><span>Update&#160;History</span></a></li>
      <li><a href="usergroup0.html"><span>Programming&#160;Guide</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference&#160;and&#160;Data&#160;Structure</span></a></li>
      <li><a href="_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F.html"><span>Sample&#160;Program</span></a></li>
      <li><a href="_error_code.html"><span>Error&#160;Code</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="PageDoc"><div class="contents">
<div class="textblock"><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div class="title">Acquire Images</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">There are three ways to get images: get images in callback function (buffers are allocated internally in SDK), get images actively (buffers are allocated internally in SDK), and get images actively (buffers are allocated externally). You can choose one as needed. Besides, the SDK also supports functions such as getting ChunkData information and setting image acquisition strategies. </div><div id="hikvision"> <ul>
<li>
<a href="#huidiaoqutu" class="el">Get Images in Callback Function (buffers are allocated internally in SDK) </a> </li>
<li>
<a href="#zhudongqutu1" class="el">Get Images Actively (buffers are allocated internally in SDK) </a> </li>
<li>
<a href="#zhudongqutu2" class="el">Get Images Actively (buffers are allocated externally) </a> </li>
<li>
<a href="#chunkdata" class="el">Get ChunkData Information </a> </li>
<li>
<a href="#peizhiqutucelue" class="el">Set Images Acquisition Strategies</a> </li>
</ul>
<br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="huidiaoqutu" class="title">1. Get Images in Callback Function (buffers are allocated internally in SDK) </div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision"> Getting images in callback function is a passive way of getting images. You only need to register a function handle inside the SDK. When images are generated, this function will be called automatically and upload the image data. This method is relatively simple in programming, but the specific process of getting images are not controllable. </div><div id="hikvision"> </div><div id="hikvision">Steps:</div><div id="hikvision"> <ol>
<li>
Get the number of stream channels of the camera: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870" title="Get the number of stream channels.">MV_FG_GetNumStreams()</a>.  </li>
<li>
Input stream channel nIndex to open the stream channel and get the stream handle: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9" title="Open the stream channel.">MV_FG_OpenStream()</a>. </li>
<li>
Set the number of SDK internal image buffers: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6" title="Set the number of internal buffers for the SDK.">MV_FG_SetBufferNum()</a>. By default, there is no image buffer inside the SDK, so this API is required to be called when setting callback function as the method to get images. The number of image buffers should depend on real situations, and the factors might be camera frame rate, image resolution, PC specifications (like motherboard and RAM), and so on.  </li>
<li>
Register callback function: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18" title="Register the callback function for frame buffer information. This API is valid only when buffers are ...">MV_FG_RegisterFrameCallBackEx()</a>. The parameter bBufferRelease decides two methods to release image buffers: true-the buffer will be released automatically after the callback function ends, false-call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> to release the buffer after the callback function ends.  </li>
<li>
Start getting images: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a>.  </li>
<li>
When the frame grabber SDK gets a frame of data, it will trigger the callback function to send the data and information to the user. Note that callback functions are not suitable for time-consuming operations, so it is recommended to create another thread to process the data.  </li>
<li>
Process the acquired image data in the callback function. There are two ways to copy image data for different bBufferRelease in <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18" title="Register the callback function for frame buffer information. This API is valid only when buffers are ...">MV_FG_RegisterFrameCallBackEx()</a>. <br />
 When bBufferRelease is true, deep copy the image data to a user-defined data buffer area. <br />
 When bBufferRelease is false, shallow copy the buffer pointer in the callback (pstBufferInfo) into the user-defined buffer list. Then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> to release the buffer back to the internal SDK.  </li>
<li>
Stop image acquisition: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b" title="Stop image acquisition.">MV_FG_StopAcquisition()</a>.  </li>
<li>
Close the stream channel: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008" title="Close the stream channel.">MV_FG_CloseStream()</a>. Note that when the stream channel is closed, the previous handle will become invalid and cannot be used to call other APIs. </li>
</ol>
</div><div id="hikvision"><img src="4.5.1.png" width="710" height="865" alt="" class="inline"/>
</div><div id="hikvision"> <br />
 </div><div id="hikvision">The following sample codes show the process of getting images in callback function. For the full sample program, refer to <a href="_grab_image__callback_8cpp-example.html" class="el">Get Images in Callback Function</a>. </div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Get the number of stream channels*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nStreamNum = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a>(hDevice, &amp;nStreamNum);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Open a stream channel (channel 0 by default)*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = NULL;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a>(hDevice, 0, &amp;hStream); </div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Set the number of internal buffers*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6">MV_FG_SetBufferNum</a>(hStream, 3);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Register image callback function*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18">MV_FG_RegisterFrameCallBackEx</a>(hStream, FrameCallBack, hStream, <span class="keyword">false</span>);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Start image acquisition*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a>(hStream);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Pause and wait for keypress*/</span></div><div class="line">WaitForKeyPress(); </div><div class="line"></div><div class="line"><span class="comment">/*Stop image acquisition*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a>(hStream);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Close the stream channel*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a>(hStream);</div><div class="line">Check(nRet);</div></div><!-- fragment --> </div><div id="hikvision">The following sample codes show how to process the images acquired in callback function: </div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Shallow copy function, which only adds a pointer to an existing buffer address*/</span></div><div class="line"><span class="keywordtype">void</span> ShallowCopyImage(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstSrcBufInfo, <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstDstBufInfo)</div><div class="line">{</div><div class="line">    memcpy(pstDstBufInfo, pstSrcBufInfo, <span class="keyword">sizeof</span>(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*Deep copy function, which allocates a new buffer for the data and copy the data to the new buffer*/</span></div><div class="line"><span class="keywordtype">void</span> DeepCopyImage(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstSrcBufInfo, <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstDstBufInfo)</div><div class="line">{</div><div class="line">    memcpy(pstDstBufInfo, pstSrcBufInfo, <span class="keyword">sizeof</span>(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>));</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pDstBuf = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)malloc(pstSrcBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>);</div><div class="line">    memcpy(pDstBuf, pstSrcBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ab48e189d395e833f208732a779e526c0">pBuffer</a>, pstSrcBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>);</div><div class="line">    pstDstBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ab48e189d395e833f208732a779e526c0">pBuffer</a> = pDstBuf;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*Image callback function*/</span></div><div class="line"><span class="keywordtype">void</span> __stdcall FrameCallBack(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstBufferInfo, <span class="keywordtype">void</span>* pUser)</div><div class="line">{</div><div class="line">    <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = (<a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>)pUser;</div><div class="line">    printf(<span class="stringliteral">&quot;Frame ID: %I64d, Filled Size: %d, Width: %d, Height: %d\r\n&quot;</span>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a93ebaf10b2b24fa20dc7860964563a22">nFrameID</a>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#abbc1b35442c6143931edc0189a3432fb">nWidth</a>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a2e4c6b811457a16b7033af6741cfb1db">nHeight</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/*You can shallow copy the image data and process it outside the callback, or deep copy the image data to the allocated buffer*/</span></div><div class="line">    <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> stDstBufInfo = {0};</div><div class="line">    </div><div class="line">    <span class="comment">/*Shallow copy function*/</span></div><div class="line">    ShallowCopyImage(pstBufferInfo, &amp;stDstBufInfo);</div><div class="line">    </div><div class="line">    <span class="comment">/*Deep copy function*/</span></div><div class="line">    <span class="comment">//DeepCopyImage(pstBufferInfo, &amp;stDstBufInfo);</span></div><div class="line"></div><div class="line">    <span class="comment">/*After you finish processing image data, call the following API to release the image buffer back to the internal SDK*/</span></div><div class="line">    <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc">MV_FG_ReleaseFrameBuffer</a>(hStream, pstBufferInfo);</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="zhudongqutu1" class="title">2. Get Images Actively (buffers are allocated internally in SDK)</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">To get images actively with buffers allocated internally in SDK, you need to create and maintain image acquisition threads. With this acquisition method, you can get images in real time as needed. Because the image buffers are allocated internally in the SDK, you also need to copy the image data to the allocated buffers and manage the data. </div><div id="hikvision"> </div><div id="hikvision">Steps: </div><div id="hikvision"> <ol>
<li>
Get the number of stream channels of the camera: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870" title="Get the number of stream channels.">MV_FG_GetNumStreams()</a>. </li>
<li>
Open the stream channel and get the stream handle: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9" title="Open the stream channel.">MV_FG_OpenStream()</a>. </li>
<li>
Set the number of SDK internal image buffer: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6" title="Set the number of internal buffers for the SDK.">MV_FG_SetBufferNum()</a>. By default, there is no image buffer inside the SDK, so this API is required to be called when setting the image acquisition method as getting images actively. The number of image buffers should depend on real situations, and the factors might include camera frame rate, image resolution, PC specifications (like motherboard and RAM), and so on. </li>
<li>
Create an image acquisition thread.  </li>
<li>
Start image acquisition: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a>.  </li>
<li>
Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="Get the buffer information of a frame. This API is valid only when buffers are requested internally b...">MV_FG_GetFrameBuffer()</a> repeatedly in the acquisition thread to get image buffer information, then process the images. After you finish processing them, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="Release the buffer information. This API is valid only when buffers are requested internally by the S...">MV_FG_ReleaseFrameBuffer()</a> to release the image buffer back to the internal SDK. </li>
<li>
Stop image acquisition: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b" title="Stop image acquisition.">MV_FG_StopAcquisition()</a>. </li>
<li>
Close the stream channel: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008" title="Close the stream channel.">MV_FG_CloseStream()</a>. Note that when the stream channel is closed, the previous handle will become invalid and cannot be used to call other APIs. </li>
</ol>
</div><div id="hikvision"><img src="4.5.2.png" width="800" alt="" class="inline"/>
</div><div id="hikvision"> </div><div id="hikvision">The following sample codes show the process of getting images actively (buffers are allocated internally in SDK). For the full sample program, refer to <a href="_grab_image_8cpp-example.html" class="el">Get Images Actively</a>.</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Get the number of stream channels*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nStreamNum = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a>(hDevice, &amp;nStreamNum);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Open a stream channel (channel 0 by default)*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = NULL;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a>(hDevice, 0, &amp;hStream); </div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Set the number of internal buffers*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6">MV_FG_SetBufferNum</a>(hStream, 3);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Create an acquisition thread*/</span></div><div class="line">g_bGrab = <span class="keyword">true</span>;</div><div class="line"><span class="keywordtype">void</span>* hThreadHandle = (<span class="keywordtype">void</span>*)_beginthreadex(NULL, 0, GrabbingThread, hStream, 0, NULL);</div><div class="line"><span class="keywordflow">if</span> (NULL == hThreadHandle)</div><div class="line">{</div><div class="line">    printf(<span class="stringliteral">&quot;Create thread failed!\n&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*Pause and wait for keypress*/</span></div><div class="line">WaitForKeyPress();</div><div class="line"></div><div class="line"><span class="comment">/*Close the acquisition thread*/</span></div><div class="line">g_bGrab = <span class="keyword">false</span>;</div><div class="line">WaitForSingleObject(hThreadHandle, INFINITE);</div><div class="line">CloseHandle(hThreadHandle);</div><div class="line">hThreadHandle = NULL;</div><div class="line"></div><div class="line"><span class="comment">/*Close the stream channel*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a>(hStream);</div><div class="line">Check(nRet);</div></div><!-- fragment --></div><div id="hikvision"></div><div id="hikvision">The following sample codes show the image acquisition thread (buffers are allocated internally in SDK).</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Image acquisition thread*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __stdcall GrabbingThread(<span class="keywordtype">void</span>* pUser)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (pUser)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = (<a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>)pUser;</div><div class="line">        <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> stFrameInfo = { 0 };</div><div class="line"></div><div class="line">        <span class="comment">/*Start acquisition*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">        <span class="keywordflow">while</span> (g_bGrab)</div><div class="line">        {</div><div class="line">            <span class="comment">/*Get image buffers*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d">MV_FG_GetFrameBuffer</a>(hStream, &amp;stFrameInfo, TIMEOUT);</div><div class="line">            <span class="keywordflow">if</span> (MV_FG_SUCCESS != nRet)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line">            printf(<span class="stringliteral">&quot;Frame ID: %I64d, Filled Size: %d, Width: %d, Height: %d\r\n&quot;</span>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a93ebaf10b2b24fa20dc7860964563a22">nFrameID</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#abbc1b35442c6143931edc0189a3432fb">nWidth</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a2e4c6b811457a16b7033af6741cfb1db">nHeight</a>);</div><div class="line">            </div><div class="line">            <span class="comment">/*Release the image buffers back to the internal SDK*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc">MV_FG_ReleaseFrameBuffer</a>(hStream, &amp;stFrameInfo);</div><div class="line">            Check(nRet);</div><div class="line">        }</div><div class="line">        <span class="comment">/*Stop acquisition*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> MV_FG_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="zhudongqutu2" class="title">3. Get Images Actively (buffers are allocated externally)</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">By allocating and registering buffers, you can get images in real-time when needed or manage the image buffers by calling related APIs. However, this method is relatively difficult in programming, and requires a better understanding of the APIs and their calling logic.</div><div id="hikvision"> </div><div id="hikvision">Steps: </div><div id="hikvision"> <ol>
<li>
Get the number of stream channels of the camera: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870" title="Get the number of stream channels.">MV_FG_GetNumStreams()</a>. </li>
<li>
Open the stream channel and get the stream handle: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9" title="Open the stream channel.">MV_FG_OpenStream()</a>. </li>
<li>
Get payload size in the stream channel: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550" title="Get the image size in the stream channel.">MV_FG_GetPayloadSize()</a>. Generally, the payload size is the image length. Note that after editing image parameters such as width, height, and pixel format, you need to get a new payload size.  </li>
<li>
Allocate certain number of image buffers according to image payload size. The number of image buffers should depend on real situations, and the factors might include camera frame rate, image resolution, PC specifications (like motherboard and RAM), and so on. </li>
<li>
Register the allocated image buffers in the internal SDK and get corresponding buffer handle of each buffer: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="Register buffer to the stream channel. This API must be called before calling MV_FG_StartAcquisition(...">MV_FG_AnnounceBuffer()</a>. So far, the registered image buffers in the SDK are placed in the unused queue and cannot be used by the SDK yet. </li>
<li>
The registered buffers are not in the input queue by default. You need to put the buffers in the SDK internal input queue by calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="Refresh the buffer queue.">MV_FG_FlushQueue()</a> (see <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a376a5f855e33f3d49b9f17af38ecaacf">MV_FG_BUFFER_QUEUE_ALL_TO_INPUT</a> for the parameter enQueueType).  </li>
<li>
Create an image acquisition thread. </li>
<li>
Start image acquisition: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="Start image acquisition.">MV_FG_StartAcquisition()</a>. </li>
<li>
Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="Get the buffer information of a frame. This API is valid only when buffers are requested internally b...">MV_FG_GetFrameBuffer()</a> repeatedly in the acquisition thread to get image buffer handle. Then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06" title="Get the buffer information via buffer handle.">MV_FG_GetBufferInfo()</a> to get image information and data. After getting image information and data, you can then process the images. After processing ends, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de" title="Put the buffer back to the input queue for further image acquisition.">MV_FG_QueueBuffer()</a> to put the buffer into the input queue for further use in image acquisition.  </li>
<li>
Stop image acquisition: <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b" title="Stop image acquisition.">MV_FG_StopAcquisition()</a>. </li>
<li>
Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="Refresh the buffer queue.">MV_FG_FlushQueue()</a> (see <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a87a272ac9e6315a6be1e7c9986e71480">MV_FG_BUFFER_QUEUE_ALL_DISCARD</a> for the parameter enQueueType) to put the buffers registered in the SDK to the unused queue. </li>
<li>
Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14afae1d79a9402ac008fa463713f3e6" title="Revoke buffer from the stream channel registered by MV_FG_AnnounceBuffer() .">MV_FG_RevokeBuffer()</a> to revoke the image buffers in the unused queue in the SDK. The revoked image buffers can then be released externally. </li>
<li>
Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008" title="Close the stream channel.">MV_FG_CloseStream()</a> to close the stream channel. Note that when the stream channel is closed, the previous handle will become invalid and cannot be used to call other APIs. </li>
</ol>
</div><div id="hikvision"><img src="4.5.3.png" width="660" height="1250" alt="" class="inline"/>
</div><div id="hikvision"> <br />
 </div><div id="hikvision">The following sample codes show the process of getting images actively (buffers are allocated externally). For the full sample program, refer to <a href="_grab_image__user_buffer_8cpp-example.html" class="el">Get Images via Externally Allocated Buffer</a>. </div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Get the number of stream channels*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nStreamNum = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a>(hDevice, &amp;nStreamNum);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Open a stream channel (channel 0 by default)*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = NULL;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a>(hDevice, 0, &amp;hStream); </div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Get the payload size in the stream channel*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPayloadSize = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550">MV_FG_GetPayloadSize</a>(hStream, &amp;nPayloadSize);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Allocate and register image buffers*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer[3] = {0};</div><div class="line"><span class="keywordtype">void</span>* pBuffer = NULL;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 3; i++)</div><div class="line">{</div><div class="line">    pBuffer = malloc(nPayloadSize);</div><div class="line">    nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7">MV_FG_AnnounceBuffer</a>(hStream, pBuffer, nPayloadSize, NULL, &amp;(hBuffer[i]));</div><div class="line">    Check(nRet);</div><div class="line">}</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Put the image buffers into the input queue*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c">MV_FG_FlushQueue</a>(hStream, <a class="code" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a376a5f855e33f3d49b9f17af38ecaacf">MV_FG_BUFFER_QUEUE_ALL_TO_INPUT</a>);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Create an acquisition thread*/</span></div><div class="line">g_bGrab = <span class="keyword">true</span>;</div><div class="line"><span class="keywordtype">void</span>* hThreadHandle = (<span class="keywordtype">void</span>*)_beginthreadex(NULL, 0, GrabbingThread, hStream, 0, NULL);</div><div class="line"><span class="keywordflow">if</span> (NULL == hThreadHandle)</div><div class="line">{</div><div class="line">    printf(<span class="stringliteral">&quot;Create thread failed!\n&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*Pause and wait for keypress*/</span></div><div class="line">WaitForKeyPress();</div><div class="line"></div><div class="line"><span class="comment">/*Close the acquisition thread*/</span></div><div class="line">g_bGrab = <span class="keyword">false</span>;</div><div class="line">WaitForSingleObject(hThreadHandle, INFINITE);</div><div class="line">CloseHandle(hThreadHandle);</div><div class="line">hThreadHandle = NULL;</div><div class="line"></div><div class="line"><span class="comment">/*Clear the buffer queue*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c">MV_FG_FlushQueue</a>(hStream, <a class="code" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a87a272ac9e6315a6be1e7c9986e71480">MV_FG_BUFFER_QUEUE_ALL_DISCARD</a>);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*Revoke and release the registered image buffers*/</span></div><div class="line"><span class="keywordtype">void</span>* pPrivate = NULL;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 3; i++)</div><div class="line">{</div><div class="line">    nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14afae1d79a9402ac008fa463713f3e6">MV_FG_RevokeBuffer</a>(hStream, hBuffer[i], &amp;pBuffer, &amp;pPrivate);</div><div class="line">    Check(nRet);</div><div class="line">    hBuffer[i] = NULL;</div><div class="line">    free(pBuffer);      </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*Close the stream channel*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a>(hStream);</div><div class="line">Check(nRet);</div></div><!-- fragment --> </div><div id="hikvision">The following sample codes show the acquisition thread (buffers are allocated externally).</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Acquisition thread*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __stdcall GrabbingThread(<span class="keywordtype">void</span>* pUser)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (pUser)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = (<a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>)pUser;</div><div class="line">        <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer = NULL;</div><div class="line">        <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> stFrameInfo = { 0 };</div><div class="line"></div><div class="line">        <span class="comment">/*Start acquisition*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">        <span class="keywordflow">while</span> (g_bGrab)</div><div class="line">        {</div><div class="line">            <span class="comment">/*Get image buffers*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba">MV_FG_GetImageBuffer</a>(hStream, &amp;hBuffer, TIMEOUT);</div><div class="line">            <span class="keywordflow">if</span> (MV_FG_SUCCESS != nRet)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/*Get image information and data*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06">MV_FG_GetBufferInfo</a>(hBuffer, &amp;stFrameInfo);</div><div class="line">            <span class="keywordflow">if</span> (MV_FG_SUCCESS == nRet)</div><div class="line">            {</div><div class="line">                printf(<span class="stringliteral">&quot;Frame ID: %I64d, Filled Size: %d, Width: %d, Height: %d\r\n&quot;</span>,</div><div class="line">                stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a93ebaf10b2b24fa20dc7860964563a22">nFrameID</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#abbc1b35442c6143931edc0189a3432fb">nWidth</a>,</div><div class="line">                stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a2e4c6b811457a16b7033af6741cfb1db">nHeight</a>);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/*Put the image buffers back to the input queue*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de">MV_FG_QueueBuffer</a>(hBuffer);</div><div class="line">            Check(nRet);</div><div class="line">        }</div><div class="line">        <span class="comment">/*Stop acquisition*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> MV_FG_SUCCESS;</div><div class="line">}</div></div><!-- fragment --></div><div id="hikvision"><br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="chunkdata" class="title">Get ChunkData Information</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2f77d11bcbc21d52cc5b6173d23a367d" title="Get the chunk data information in the buffer.">MV_FG_GetBufferChunkData()</a> and input image buffers to get the ChunkData information in the image buffers. This API should be called after getting the image buffers, and before the buffers are put back into the internal SDK. </div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Get the ChunkData information in the image buffers*/</span></div><div class="line"><a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a> stChunkDataInfo = {0};</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a578bc8184556174255cd35bcf7d540e7">nNumChunks</a>; i++)</div><div class="line">{</div><div class="line">    memset(&amp;stChunkDataInfo, 0, <span class="keyword">sizeof</span>(<a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a>));</div><div class="line">    nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2f77d11bcbc21d52cc5b6173d23a367d">MV_FG_GetBufferChunkData</a>(hStream, &amp;stBufferInfo, i, &amp;stChunkDataInfo);</div><div class="line">    Check(nRet);</div><div class="line">    printf(<span class="stringliteral">&quot;Chunk ID[%#x], Chunk length[%d]\n&quot;</span>, stChunkDataInfo.<a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html#a45254518e0f8137849ce75d381d671ef">nChunkID</a>, </div><div class="line">    stChunkDataInfo.<a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html#a5c2386c95f4c4b59c072f204d236af6e">nChunkLen</a>);</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="peizhiqutucelue" class="title">Set Image Acquisition Strategies</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga41f3a68612ff0df995d91306d4e971fe" title="Set acquisition strategy.">MV_FG_SetGrabStrategy()</a> to set the image acquisition strategy of the current stream channel. Currently, there are four types of strategies, and the default is OneByOne. You can choose one as needed. For details, refer to <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga0d0f0d8c342ed8ae22462ce20bf9bd13">MV_FG_GRAB_STRATEGY</a>. Meanwhile, this API also supports enabling trash buffer, which allows allocating another image buffer for image acquisition when the available buffer queue is empty. This can protect the continuity of image acquisition and can help count the precise number of output images from the frame grabber.</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*Set the image acquisition strategy as LatestImages and enable trash buffer*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga41f3a68612ff0df995d91306d4e971fe">MV_FG_SetGrabStrategy</a>(hStream, <a class="code" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#gga32523e01d58a150ced054a22cb911f34afe1948479db556db22759373784794a2">MV_FG_GrabStrategy_LatestImages</a>, <span class="keyword">true</span>);</div><div class="line">Check(nRet);</div></div><!-- fragment --> <br />
 </div> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>