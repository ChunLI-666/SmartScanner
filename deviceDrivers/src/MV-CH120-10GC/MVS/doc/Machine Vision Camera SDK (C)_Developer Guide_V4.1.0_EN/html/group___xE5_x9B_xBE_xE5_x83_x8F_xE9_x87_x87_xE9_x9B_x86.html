<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Disclaimer</span></a></li>
      <li><a href="_home_page.html"><span>Home&#160;Page</span></a></li>
      <li><a href="_update_history.html"><span>Update&#160;History</span></a></li>
      <li><a href="_environment_configuration.html"><span>Environment&#160;Configuration</span></a></li>
      <li><a href="_programming_guide.html"><span>Programming&#160;Guide</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Structure&#160;Definition</span></a></li>
      <li><a href="_camera_parameter_node_table.html"><span>Camera&#160;Parameter&#160;Node&#160;Table</span></a></li>
      <li><a href="examples.html"><span>Sample&#160;Program</span></a></li>
      <li><a href="_error_code.html"><span>Error&#160;Code</span></a></li>
      <li><a href="_f_a_q.html"><span>FAQ</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Acquisition</div>  </div>
</div><!--header-->
<div class="contents">

<p>Including APIs for acquiring images (directly or in callback function), starting and stopping acquisition, etc. It is supported to perform ISP algorithm processing on images inside the API via the configuration file generated by the ISP tool. Before using the ISP tool, an ISP plug-in library needs to be installed, and a folder named "ISPTool" needs to be created in the personal directory in the C disk (for example, C:\Users(user name)\ISPTool). In addition, the configuration file generated when connecting the camera should be placed in a folder named with the camera model or serial No., and placed inside the ISPTool folder. To get the configuration file, contact technical support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga48d1c4ef073e39622fa01994a8fe010c"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga48d1c4ef073e39622fa01994a8fe010c">MV_CC_RegisterImageCallBackEx</a> (IN void *handle, IN void(__stdcall *cbOutput)(unsigned char *pData, <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pFrameInfo, void *pUser), IN void *pUser)</td></tr>
<tr class="memdesc:ga48d1c4ef073e39622fa01994a8fe010c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register image data callback function, supporting getting chunk information.  <a href="#ga48d1c4ef073e39622fa01994a8fe010c">More...</a><br /></td></tr>
<tr class="separator:ga48d1c4ef073e39622fa01994a8fe010c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6954f9096ccd7f2c270e095d6f6fea8"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae6954f9096ccd7f2c270e095d6f6fea8">MV_CC_RegisterImageCallBackForRGB</a> (IN void *handle, IN void(__stdcall *cbOutput)(unsigned char *pData, <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pFrameInfo, void *pUser), IN void *pUser)</td></tr>
<tr class="memdesc:gae6954f9096ccd7f2c270e095d6f6fea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register RGB24 image data callback function.  <a href="#gae6954f9096ccd7f2c270e095d6f6fea8">More...</a><br /></td></tr>
<tr class="separator:gae6954f9096ccd7f2c270e095d6f6fea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e611d0443faab309a94565b7b07048a"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga7e611d0443faab309a94565b7b07048a">MV_CC_RegisterImageCallBackForBGR</a> (IN void *handle, IN void(__stdcall *cbOutput)(unsigned char *pData, <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pFrameInfo, void *pUser), IN void *pUser)</td></tr>
<tr class="memdesc:ga7e611d0443faab309a94565b7b07048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register BGR24 image data callback function.  <a href="#ga7e611d0443faab309a94565b7b07048a">More...</a><br /></td></tr>
<tr class="separator:ga7e611d0443faab309a94565b7b07048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78728211c47c6f118110fde635d6ac69"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69">MV_CC_StartGrabbing</a> (IN void *handle)</td></tr>
<tr class="memdesc:ga78728211c47c6f118110fde635d6ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start acquiring images.  <a href="#ga78728211c47c6f118110fde635d6ac69">More...</a><br /></td></tr>
<tr class="separator:ga78728211c47c6f118110fde635d6ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d7f4ae46a53851f104e26fa449ab06"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae5d7f4ae46a53851f104e26fa449ab06">MV_CC_StopGrabbing</a> (IN void *handle)</td></tr>
<tr class="memdesc:gae5d7f4ae46a53851f104e26fa449ab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop acquiring images.  <a href="#gae5d7f4ae46a53851f104e26fa449ab06">More...</a><br /></td></tr>
<tr class="separator:gae5d7f4ae46a53851f104e26fa449ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242bac9388de9cb8076e0a0b3dc0e724"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga242bac9388de9cb8076e0a0b3dc0e724">MV_CC_GetImageForRGB</a> (IN void *handle, IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pstFrameInfo, IN int nMsec)</td></tr>
<tr class="memdesc:ga242bac9388de9cb8076e0a0b3dc0e724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a frame of RGB24 data, search the frame data in the memory and transform it to RGB24 format for return. Setting timeout is supported.  <a href="#ga242bac9388de9cb8076e0a0b3dc0e724">More...</a><br /></td></tr>
<tr class="separator:ga242bac9388de9cb8076e0a0b3dc0e724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae268407dfa03f526984cb845ae5b908f"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae268407dfa03f526984cb845ae5b908f">MV_CC_GetImageForBGR</a> (IN void *handle, IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pstFrameInfo, IN int nMsec)</td></tr>
<tr class="memdesc:gae268407dfa03f526984cb845ae5b908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a frame of BGR24 data, search the frame data in the memory and transform it to BGR24 format for return. Setting timeout is supported.  <a href="#gae268407dfa03f526984cb845ae5b908f">More...</a><br /></td></tr>
<tr class="separator:gae268407dfa03f526984cb845ae5b908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33331585a4e2a64653b74af66157a6d8"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8">MV_CC_GetImageBuffer</a> (IN void *handle, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *pstFrame, IN unsigned int nMsec)</td></tr>
<tr class="memdesc:ga33331585a4e2a64653b74af66157a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one frame of picture using internal buffer.  <a href="#ga33331585a4e2a64653b74af66157a6d8">More...</a><br /></td></tr>
<tr class="separator:ga33331585a4e2a64653b74af66157a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff416b2d35df148fa2e63521d8847d3"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3">MV_CC_FreeImageBuffer</a> (IN void *handle, IN <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *pstFrame)</td></tr>
<tr class="memdesc:gaeff416b2d35df148fa2e63521d8847d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release image buffer. This API is used to release the image buffer which is no longer used, and it should be used with <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> in pairs.  <a href="#gaeff416b2d35df148fa2e63521d8847d3">More...</a><br /></td></tr>
<tr class="separator:gaeff416b2d35df148fa2e63521d8847d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb284e0ae3eeced7e1f9395317800c6f"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f">MV_CC_GetOneFrameTimeout</a> (IN void *handle, IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pstFrameInfo, IN unsigned int nMsec)</td></tr>
<tr class="memdesc:gafb284e0ae3eeced7e1f9395317800c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one frame of picture, and the SDK waits internally until data is returned.  <a href="#gafb284e0ae3eeced7e1f9395317800c6f">More...</a><br /></td></tr>
<tr class="separator:gafb284e0ae3eeced7e1f9395317800c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga90fcfa3fb929d76e99ea7f5946d6c5ff">MV_CC_ClearImageBuffer</a> (IN void *handle)</td></tr>
<tr class="memdesc:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the streaming data buffer.  <a href="#ga90fcfa3fb929d76e99ea7f5946d6c5ff">More...</a><br /></td></tr>
<tr class="separator:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga68d7ec74d6c37907cb868f0ff7f9251e">MV_CC_GetValidImageNum</a> (IN void *handle, IN OUT unsigned int *pnValidImageNum)</td></tr>
<tr class="memdesc:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid images in the current image buffer.  <a href="#ga68d7ec74d6c37907cb868f0ff7f9251e">More...</a><br /></td></tr>
<tr class="separator:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Including APIs for acquiring images (directly or in callback function), starting and stopping acquisition, etc. It is supported to perform ISP algorithm processing on images inside the API via the configuration file generated by the ISP tool. Before using the ISP tool, an ISP plug-in library needs to be installed, and a folder named "ISPTool" needs to be created in the personal directory in the C disk (for example, C:\Users(user name)\ISPTool). In addition, the configuration file generated when connecting the camera should be placed in a folder named with the camera model or serial No., and placed inside the ISPTool folder. To get the configuration file, contact technical support. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga48d1c4ef073e39622fa01994a8fe010c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d1c4ef073e39622fa01994a8fe010c">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN &#160;</td>
          <td class="paramname"><em>void</em>__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register image data callback function, supporting getting chunk information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] Image data callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>After calling <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE5_x88_x9D_xE5_xA7_x8B_xE5_x8C_x96_xE5_x8F_x8A_xE9_x94_x80_xE6_xAF_x81.html#gab0a5b929b0bec89c1b2a66c7b30493ed" title="Create device handle.">MV_CC_CreateHandle()</a> , call this API to set image data callback function.<br />
 There are two available image data acquisition modes, and cannot be used together: <br />
 Mode 1: Call <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga57fe8d047993a1b8011b7a0d334c9801" title="Register image data callback (This API is obsolete. It is recommended to use MV_CC_GetOneFrameTimeOut...">MV_CC_RegisterImageCallBack()</a> to set image data callback function, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start acquisition. The acquired image data will be returned in the set callback function.<br />
 Mode 2: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start acquisition, and then call <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#gad0621c9b4ee6eca2b8ab3432309e11c0" title="Get one frame data. This API is used for query to get data. It will inquire whether the internal cach...">MV_CC_GetOneFrame()</a> repeatedly in application layer to get frame data of specified pixel format. When getting frame data, the frequency of calling this API should be controlled by upper layer application according to frame rate. <br />
 This API is not supported by CameraLink device. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_grab__image_callback_8cpp-example.html#a23">Grab_ImageCallback.cpp</a>, and <a class="el" href="_trigger__image_callback_8cpp-example.html#a26">Trigger_ImageCallback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gae6954f9096ccd7f2c270e095d6f6fea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6954f9096ccd7f2c270e095d6f6fea8">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackForRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackForRGB </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN &#160;</td>
          <td class="paramname"><em>void</em>__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register RGB24 image data callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] RGB24 image data callback function </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>After calling <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE5_x88_x9D_xE5_xA7_x8B_xE5_x8C_x96_xE5_x8F_x8A_xE9_x94_x80_xE6_xAF_x81.html#gab0a5b929b0bec89c1b2a66c7b30493ed" title="Create device handle.">MV_CC_CreateHandle()</a> , call this API to set image data callback function.<br />
 There are two available image data acquisition modes, and cannot be used together: <br />
 Mode 1: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae6954f9096ccd7f2c270e095d6f6fea8" title="Register RGB24 image data callback function.">MV_CC_RegisterImageCallBackForRGB()</a> to set RGB24 format image data callback function, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start acquisition. The collected image data will be returned in the configured callback function.<br />
 Mode 2: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start acquisition, and the call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga242bac9388de9cb8076e0a0b3dc0e724" title="Get a frame of RGB24 data, search the frame data in the memory and transform it to RGB24 format for r...">MV_CC_GetImageForRGB()</a> repeatedly in application layer to get frame data with RGB24 format. When getting frame data, the upper application program should control the frequency of calling this API according to frame rate. <br />
 This API is not supported by CameraLink device. </dd></dl>

</div>
</div>
<a id="ga7e611d0443faab309a94565b7b07048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e611d0443faab309a94565b7b07048a">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackForBGR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackForBGR </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN &#160;</td>
          <td class="paramname"><em>void</em>__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register BGR24 image data callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] BGR24 image data callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>After calling MV_CC_CreateHandle, call this API to set image data callback function. <br />
 There are two available image data acquisition modes, and cannot be used together: <br />
 Mode 1: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga7e611d0443faab309a94565b7b07048a" title="Register BGR24 image data callback function.">MV_CC_RegisterImageCallBackForBGR()</a> to set RGB24 format image data callback function, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start acquisition. The collected image data will be returned in the configured callback function.<br />
 Mode 2: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start acquisition, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae268407dfa03f526984cb845ae5b908f" title="Get a frame of BGR24 data, search the frame data in the memory and transform it to BGR24 format for r...">MV_CC_GetImageForBGR()</a> repeatedly in application layer to get frame data with BGR24 format. When getting frame data, the upper application program should control the frequency of calling this API according to frame rate.<br />
 This API is not supported by CameraLink device. </dd></dl>

</div>
</div>
<a id="ga78728211c47c6f118110fde635d6ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78728211c47c6f118110fde635d6ac69">&#9670;&nbsp;</a></span>MV_CC_StartGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_StartGrabbing </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start acquiring images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API is not supported by CameraLink device. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a30">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a16">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a18">Display.cpp</a>, <a class="el" href="_events_8cpp-example.html#a29">Events.cpp</a>, <a class="el" href="_grab__image_callback_8cpp-example.html#a24">Grab_ImageCallback.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a26">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a29">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a31">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwith_decode_8cpp-example.html#a59">HighBandwithDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a21">ImageProcess.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a30">MultiCast.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a31">ReconnectDemo.cpp</a>, <a class="el" href="_trigger__image_8cpp-example.html#a29">Trigger_Image.cpp</a>, and <a class="el" href="_trigger__image_callback_8cpp-example.html#a27">Trigger_ImageCallback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gae5d7f4ae46a53851f104e26fa449ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d7f4ae46a53851f104e26fa449ab06">&#9670;&nbsp;</a></span>MV_CC_StopGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_StopGrabbing </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop acquiring images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API is not supported by CameraLink device. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a31">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a17">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a20">Display.cpp</a>, <a class="el" href="_events_8cpp-example.html#a30">Events.cpp</a>, <a class="el" href="_grab__image_callback_8cpp-example.html#a25">Grab_ImageCallback.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a27">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a30">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a32">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwith_decode_8cpp-example.html#a79">HighBandwithDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a33">ImageProcess.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a31">MultiCast.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a20">ReconnectDemo.cpp</a>, <a class="el" href="_trigger__image_8cpp-example.html#a30">Trigger_Image.cpp</a>, and <a class="el" href="_trigger__image_callback_8cpp-example.html#a28">Trigger_ImageCallback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga242bac9388de9cb8076e0a0b3dc0e724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242bac9388de9cb8076e0a0b3dc0e724">&#9670;&nbsp;</a></span>MV_CC_GetImageForRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetImageForRGB </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned char *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *&#160;</td>
          <td class="paramname"><em>pstFrameInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a frame of RGB24 data, search the frame data in the memory and transform it to RGB24 format for return. Setting timeout is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pData</td><td>[IN][OUT] Buffer address used to save image data. </td></tr>
    <tr><td class="paramname">nDataSize</td><td>[IN] Buffer size. </td></tr>
    <tr><td class="paramname">pstFrameInfo</td><td>[IN][OUT] Obtained frame information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] Waiting timeout, unit: millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>
Each time the API is called, the internal buffer is checked for data. If there is data, it will be transformed to RGB24 format for return. If there is no data, error code will be returned. As it takes time to transform the image to RGB24 format, this API might cause frame loss when data frame rate is too high. </li>
<li>
Before calling this API to get image data frame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API gets frame data actively, so the upper layer program should control the frequency of calling this API according to the frame rate. </li>
<li>
This API is not supported by CameraLink device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae268407dfa03f526984cb845ae5b908f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae268407dfa03f526984cb845ae5b908f">&#9670;&nbsp;</a></span>MV_CC_GetImageForBGR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetImageForBGR </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned char *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *&#160;</td>
          <td class="paramname"><em>pstFrameInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a frame of BGR24 data, search the frame data in the memory and transform it to BGR24 format for return. Setting timeout is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pData</td><td>[OUT] Buffer address used to save image data. </td></tr>
    <tr><td class="paramname">nDataSize</td><td>[IN] Buffer size. </td></tr>
    <tr><td class="paramname">pstFrameInfo</td><td>[OUT] Obtained frame information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] Waiting timeout, unit: millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>
Each time the API is called, the internal buffer is checked for data. If there is data, it will be transformed to RGB24 format for return. If there is no data, error code will be returned. As it takes time to transform the image to RGB24 format, this API might cause frame loss when data frame rate is too high. </li>
<li>
Before calling this API to get image data frame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API gets frame data actively, so the upper layer program should control the frequency of calling this API according to the frame rate. </li>
<li>
This API is not supported by CameraLink device. </li>
</ul>
<pre class="fragment"></pre> </dd></dl>

</div>
</div>
<a id="ga33331585a4e2a64653b74af66157a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33331585a4e2a64653b74af66157a6d8">&#9670;&nbsp;</a></span>MV_CC_GetImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *&#160;</td>
          <td class="paramname"><em>pstFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one frame of picture using internal buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN][OUT] Image data and information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] Timeout duration, unit: millisecond. Input INFINITE to set unlimited timeout period, and image acquisition will not stop until receiving a frame of picture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>
Before calling this API to get image data frame, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API gets frame data actively, so the upper layer program should control the frequency of calling this API according to the frame rate. This API supports setting timeout, and SDK will wait to return until data appears. This function will increase the streaming stability, which can be used in the situation with high stability requirement.  </li>
<li>
This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Release image buffer. This API is used to release the image buffer which is no longer used,...">MV_CC_FreeImageBuffer()</a> should be called in pairs, after processing the acquired data, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Release image buffer. This API is used to release the image buffer which is no longer used,...">MV_CC_FreeImageBuffer()</a> to release the data pointer permission of pstFrame.  </li>
<li>
This API's streaming buffer is allocated by the SDK internally, so it has higher image acquisition efficiency than MV_CC_GetOneFrameTimeout () , whose streaming buffer needs to be manually allocated by the user.  </li>
<li>
This API cannot be called to stream after calling <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga3d79377333891ab4f3e9ba352757eca7" title="Display acquired images (cannot be used with MV_CC_GetImageBuffer() at the same time).">MV_CC_Display()</a> .  </li>
<li>
This API is not supported by CameraLink device.  </li>
<li>
This API is supported by both USB3 vision camera and GigE camera.  </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_grab_image__high_performance_8cpp-example.html#a13">GrabImage_HighPerformance.cpp</a>, and <a class="el" href="_high_bandwith_decode_8cpp-example.html#a62">HighBandwithDecode.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaeff416b2d35df148fa2e63521d8847d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff416b2d35df148fa2e63521d8847d3">&#9670;&nbsp;</a></span>MV_CC_FreeImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_FreeImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *&#160;</td>
          <td class="paramname"><em>pstFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release image buffer. This API is used to release the image buffer which is no longer used, and it should be used with <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> in pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN] Image data and information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>
This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> should be called in pairs. Before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> to get image data pstFrame, you should call this API to release the permission.  </li>
<li>
Compared with the API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f" title="Get one frame of picture, and the SDK waits internally until data is returned.">MV_CC_GetOneFrameTimeout()</a> , this API has higher efficiency of image acquisition. The max. number of nodes that can be outputted from <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a>(without freeing the buffer) is the same as the "nNum" from API <a class="el" href="group___xE9_x80_x9A_xE7_x94_xA8_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2088ec54d617eb629412729e0241067d" title="Set the number of SDK internal image buffer nodes.">MV_CC_SetImageNodeNum()</a> . The default value is 1.  </li>
<li>
This API is not supported by CameraLink device.  </li>
<li>
This API is supported by both USB3 vision camera and GigE camera.  </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_grab_image__high_performance_8cpp-example.html#a19">GrabImage_HighPerformance.cpp</a>, and <a class="el" href="_high_bandwith_decode_8cpp-example.html#a68">HighBandwithDecode.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gafb284e0ae3eeced7e1f9395317800c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb284e0ae3eeced7e1f9395317800c6f">&#9670;&nbsp;</a></span>MV_CC_GetOneFrameTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameTimeout </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned char *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *&#160;</td>
          <td class="paramname"><em>pstFrameInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one frame of picture, and the SDK waits internally until data is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pData</td><td>[IN][OUT] Buffer address used to save image data </td></tr>
    <tr><td class="paramname">nDataSize</td><td>[IN] Buffer size. </td></tr>
    <tr><td class="paramname">pstFrameInfo</td><td>[IN][OUT] Obtained frame information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] Waiting timeout, unit: millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>
Before calling this API to get image data frame, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start acquiring images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API gets frame data actively, so the upper layer program should control the frequency of calling this API according to the frame rate. This API supports setting timeout, and SDK will wait to return until data appears. This function will increase the streaming stability, which can be used in the situation with high stability requirement.  </li>
<li>
This API is supported by both the USB3Vision and GIGE camera. </li>
<li>
This API is not supported by CameraLink device. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a15">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a1">ConnectSpecCamera.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a15">GrabImage.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a18">GrabMultipleCamera.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a23">ImageProcess.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a13">MultiCast.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a15">ReconnectDemo.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a16">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga90fcfa3fb929d76e99ea7f5946d6c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90fcfa3fb929d76e99ea7f5946d6c5ff">&#9670;&nbsp;</a></span>MV_CC_ClearImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_ClearImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the streaming data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>
You can call this API to clear the needless images in the buffer even when the streaming is in progress. </li>
<li>
You can call this API to clear history data when the continuous mode is switched to the trigger mode.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga68d7ec74d6c37907cb868f0ff7f9251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68d7ec74d6c37907cb868f0ff7f9251e">&#9670;&nbsp;</a></span>MV_CC_GetValidImageNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetValidImageNum </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnValidImageNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of valid images in the current image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pnValidImageNum</td><td>[IN][OUT] The number of valid images in the current image buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return <a class="el" href="_error_code.html">MV_OK</a> on success, and return <a class="el" href="_error_code.html">Error Code</a> on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>